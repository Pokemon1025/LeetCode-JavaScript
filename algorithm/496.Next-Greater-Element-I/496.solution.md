#### 解题关键

给定两个数组，`nums1`每一个元素都包含在`nums2`中，都**没有重复元素**，要理解 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。

为了避免`nums2`中的元素被 scan 很多次，应使用**单调栈**来优化算法。

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释: 
    对于num1中的数字4，无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
```

#### 解题思路

方法一：暴力解法 - 双重遍历

1. 遍历`nums1`元素
2. 遍历`nums2`元素，确定`nums1`中元素出现的位置，go over 之后的元素

时间复杂度：`O(m*n)`

空间复杂度：`O(m)`

方法二：优化运行时间的暴力解法

1. 把`nums2`中的所有元素以及对应的index存储在一个`map`中，使查找`nums1`在`nums2`中的位置的时候可以直接获取位置
2. 用同样的方式 go over 剩下的元素

时间复杂度：`O(m*n)`

空间复杂度：`O(m+n)` (额外使用了一个map)

> 方法二本质上没有带来性能优化，但是在实际运行中会带来运行时间的优化。

方法二：单调栈

1. 留大元素：从右往左扫描`nums2`中的元素，每一个被扫描的元素都和栈顶进行比较，如果栈不为空且当前元素大于栈顶元素，就把当前的栈顶从栈中**出栈**，直到栈为空或当前元素小于栈顶元素 。
2. 如果栈为空，说明没有存在下一个比其大的数，返回 `-1`
3. 如果当前元素小于栈顶元素，当前栈顶元素就是当前扫描元素的一个结果，把结果记录在一个map中。
4. 遍历`nums1`从对应的map中取出结果。

单调栈解例题时map记录如下：

```
2:-1 4:-1 3:4 1:3
```

时间复杂度：`O(m+n)`

空间复杂度：`O(m+n)`

#### 注意

> 理解栈顶一定是Next Greater Element，pop出的元素一定不是结果。

